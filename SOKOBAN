#include <iostream>
#include <stdio.h>
#include <stack>
#include <queue>
#include <vector>
using namespace std;
const int MAX = 12;

char field[MAX][MAX];

int dx[] = { -1, 0, 1, 0 };
int dy[] = { 0, 1, 0, -1 };
int hx = 0;
int hy = 0;
int bx = 0;
int by = 0;
int i = 0;
int j = 0;
int n = 0;
int m = 0;
int lx = 0;
int ly = 0;

/************************************************/
/************************************************/
class Pos {
private:
	unsigned short a;

public:
	Pos* prev;
	Pos();
	Pos(const int & hx, const int & hy, const int & bx, const int & by, Pos* prev);
	void setHx(const int & hx);
	char getHx();
	void setHy(const int & hy);
	char getHy();
	void setBx(const int & bx);
	char getBx();
	void setBy(const int & by);
	char getBy();
	void print(const int & num, const int & n, const int & m, const int & lx, const int & ly, const char field[MAX][MAX]);
};
/************************************************/
/************************************************/
bool isFinal(Pos& p, const int & lx, const int & ly);
void trace(vector<Pos*>& a, const int & n, const int & m, const int & lx, const int & ly, const char field[MAX][MAX]);
bool solve(Pos& start, const int & n, const int & m,
	const int dx[], const int dy[], int lx, int ly,
	const char field[MAX][MAX]);
/************************************************/
/************************************************/


int main() {
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
	scanf("%d %d\n", &n, &m);
	for (i = 0; i < MAX; ++i) {
		for (j = 0; j < MAX; ++j) {
			field[j] = '#';
		}
	}
	for (i = 1; i < n + 1; ++i) {
		for (j = 1; j < m + 1; ++j) {
			char tmp = 0;
			scanf("%c", &tmp);
			field[j] = tmp;
			if (tmp == 'B') {
				bx = i;
				by = j;
				field[j] = '.';
			}
			if (tmp == 'L') {
				lx = i;
				ly = j;
				field[j] = '.';
			}
			if (tmp == 'H') {
				hx = i;
				hy = j;
				field[j] = '.';
			}
		}
		scanf("\n");
	}

	Pos start(hx, hy, bx, by, NULL);
	if (!solve(start, n, m, dx, dy, lx, ly, field)) {
		printf("No solution.\n");
	}
	return 0;

}


/******************************************************/
/******************************************************/
Pos::Pos()
{
	a = 0;
};
Pos::Pos(const int & hx, const int & hy, const int & bx, const int & by, Pos* prev) {
	a = 0;
	setHx(hx);
	setHy(hy);
	setBx(bx);
	setBy(by);
	this->prev = prev;
};
void Pos::setHx(const int & hx)
{
	a += hx;
};
char Pos::getHx() {
	return (a % 11);
};
void Pos::setHy(const int & hy)
{
	a += hy * 11;
};
char Pos::getHy()
{
	return ((a / 11) % 11);
};
void Pos::setBx(const int & bx)
{
	a += bx * 121;
};
char Pos::getBx()
{
	return ((a / 121) % 11);
};
void Pos::setBy(const int & by)
{
	a += by * (121 * 11);
};
char Pos::getBy()
{
	return ((a / (121 * 11)) % 11);
};
void Pos::print(const int & num, const int & n, const int & m, const int & lx, const int & ly, const char field[MAX][MAX])
{
	printf("Step: %d\n", num);
	for (char i = 1; i < n + 1; ++i) {
		for (char j = 1; j < m + 1; ++j) {
			if (i == lx && j == ly) {
				printf("L");
				continue;
			}
			if (i == getBx() && j == getBy()) {
				printf("B");
				continue;
			}
			if (i == getHx() && j == getHy()) {
				printf("H");
				continue;
			}
			printf("%c", field[j]);
		}
		printf("\n");
	}
	printf("\n");
}
/************************************************/
/************************************************/
bool isFinal(Pos& p, const int & lx, const int & ly)
{
	if (p.getBx() == lx && p.getBy() == ly) {
		return true;
	}
	return false;
}
void trace(vector<Pos*>& a, const int & n, const int & m, const int & lx, const int & ly, const char field[MAX][MAX])
{
	Pos* current = a.back();
	printf("ans size : %d\n", a.size());
	stack<Pos> st;
	int i = 0;
	while (current != NULL) {
		st.push(*current);
		current = current->prev;
	}
	printf("Answer: %d\n", st.size());
	while (!st.empty()) {
		st.top().print(i, n, m, lx, ly, field);
		st.pop();
		++i;
	}
}
bool solve(Pos& start, const int & n, const int & m,
	const int dx[], const int dy[], int lx, int ly,
	const char field[MAX][MAX])
{
	char was[MAX][MAX][MAX][MAX] = {};
	queue<Pos*> q;
	vector<Pos*> ans;
	q.push(&start);
	while (!q.empty()) {
		Pos* curr = q.front();
		char hx = curr->getHx();
		char hy = curr->getHy();
		char bx = curr->getBx();
		char by = curr->getBy();
		was[hx][hy][bx][by] = 2;
		for (int i = 0; i < 4; ++i) {
			char newhx = hx + dx;
			char newhy = hy + dy;
			char newbx = bx, newby = by;
			if (field[newhx][newhy] == '#') {
				continue;
			}
			if (newhx == bx && newhy == by) {
				newbx = bx + dx;
				newby = by + dy;
				if (field[newbx][newby] == '#') {
					continue;
				}
			}
			if (was[newhx][newhy][newbx][newby] != 0) {
				continue;
			}
			Pos* p = new Pos(newhx, newhy, newbx, newby, curr);
			if (isFinal(*p, lx, ly)) {
				ans.push_back(p);
				trace(ans, n, m, lx, ly, field);
				return true;
			}
			q.push(p);
			ans.push_back(curr);
			was[newhx][newhy][newbx][newby] = 1; // in queue
		}
		q.pop();
	}
	return false;
}
